import{_ as o,p as t,q as s,t as e,R as n}from"./framework-5866ffd3.js";const _={},a=n("p",null,"spring中进行事务管理，是使用了动态代理技术，为 拦截的bean 生成代理，这样在调用bean方法是可以进行事务管理。",-1),l=n("p",null,"我想要实现一个非常简单的事务管理框架，能在ioc容器中进行声明，即可进行事务管理。",-1),c=n("p",null,"首先详细的分析 spring的实现过程：",-1),i=n("p",null,"     1，定义sessionFactory",-1),r=n("p",null,"     2,将sessionFactory 注入到 transactionManager中，使其能托管",-1),p=n("p",null,"     3，然后配置 beanNameProxy, 需要事务管理的beanName这样读取bean的时候 会从 这里生成代理",-1),d=n("p",null,"     4，配置要拦截的method的 事务隔离属性",-1),h=n("p",null," 这样，当从ioc中取bean的时候 会根据 beanNameProxy 中配置的 beanname决定 是否需要从这里生成bean",-1),u=n("p",null," 从这里生成bean之后，然后根据配置的 method的隔离级别 在transcationManager中开启事务，执行 bean中的方法",-1),m=n("p",null," 执行完成后，根据返回结果决定是否 提交 或者回滚。",-1),b=n("p",null,"    5，到这里事务就完全实现了，还需要看看 spring中的代码，这也应该是aop的实现方式",-1),f=n("p",null,"去看看具体的实现代码，简化一下实现我的需求就好。",-1),x=n("p",null,"完成后会分享给大家的  ",-1),g=n("p",null," ",-1);function N(y,B){return t(),s("div",null,[a,e(),l,e(),c,e(),i,e(),r,e(),p,e(),d,e(),h,e(),u,e(),m,e(),b,e(),f,e(),x,e(),g])}const v=o(_,[["render",N],["__file","2011-85.html.vue"]]);export{v as default};
