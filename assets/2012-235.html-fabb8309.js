import{_ as l,p as n,q as t,R as e}from"./framework-5866ffd3.js";const c={},o=e("ol",null,[e("li",null," 任务列表, 使用生产者消费者模型就足以, 为了性能考虑,应该有专门的线程监听连接,然后直接添加到任务列表后返回继续监听,由于系统中的内存和线程上下文切换的开销,采用线程池控制运行的线程数.线程循环从任务列表中取得任务并执行 "),e("li",null," 日志记录,要求详细的日志记录,在调试和运维期间能更加方便的找出问题原因 "),e("li",null," 性能监控,实时的性能监控是高性能程序必备的功能,找出瓶颈然后优化 "),e("li",null," map/reduce模型,针对分布式的,单机可用多任务列表来模拟,核心思想是将大任务分解成几个小任务,然后分发到不同的任务列表中,然后在reduce中将结果进行汇总 "),e("li",null," 结合任务列表实现异步,想想nodejs, 也是单线程实现事件分发,来达到异步效果的(这个要好好想想实现思路) ")],-1),_=[o];function s(r,u){return n(),t("div",null,_)}const i=l(c,[["render",s],["__file","2012-235.html.vue"]]);export{i as default};
