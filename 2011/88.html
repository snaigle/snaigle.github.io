<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
     <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>spring security 源码解读 1</title>
  
    <meta name="author" content="盒子">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
<script src="/assets/twitter/javascripts/qrcode.js"></script>
 

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

  <nav class="navbar navbar-expand-lg navbar-light bg-light">
  <a class="navbar-brand" href="/">韭菜盒子</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
     
              


   <li class="nav-item">
        <a class="nav-link" href="/archive">归档</a>
      </li>


      
              


   <li class="nav-item">
        <a class="nav-link" href="/tags">标签</a>
      </li>


      
              


   <li class="nav-item">
        <a class="nav-link" href="/categories">分类</a>
      </li>


      
              


   <li class="nav-item">
        <a class="nav-link" href="/pages">分页</a>
      </li>


      
              


   <li class="nav-item">
        <a class="nav-link" href="/about">关于我</a>
      </li>


      
    </ul>
  </div>
</nav>
    <div class="container">
        <div class="page-header">
  <h1>spring security 源码解读 1 </h1>
</div>

<div class="row">
  <div class="span8">
    <p>
    这一阵子看到了security，很感兴趣。于是研究一下，我在javaeye上查了好多相关的文档，收益匪浅，从入门级的配置问题，到源码级的解读都非常不错，但是还要自己在亲自走一遍流程才踏实。
</p>
<p>
    <br />
</p>
<p>
    我看的security 3.0的源码，原因是 security 2.0 的源码没办法通过maven获取到 。
</p>
<p>
    <br />
</p>
<p>
    首先 security的控制内容有： url，method，session三种，我项目中用到的只有 url。下面就按url的流程来走。
</p>
<p>
    思路： &nbsp;使用filter，过滤所有的url 如 /* 这样，并且这个filter应在最前面，道理就不到说了吧。
</p>
<p>
    1》 security使用的 filter是 org.springframework.web.filter.DelegatingFilterProxy类，在spring-web jar中。
</p>
<p>
<pre class="prettyprint lang-java linenums">    protected void initFilterBean() throws ServletException { 
        if (this.targetBeanName == null) {
            this.targetBeanName = getFilterName();
        }
        synchronized (this.delegateMonitor) {
            WebApplicationContext wac = findWebApplicationContext();
            if (wac != null) {
                this.delegate = initDelegate(wac);
            }
        }
    }

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain filterChain) throws ServletException, IOException { 
        Filter delegateToUse = null;
        synchronized (this.delegateMonitor) {
            if (this.delegate == null) {
                WebApplicationContext wac = findWebApplicationContext();
                if (wac == null) {
                    throw new IllegalStateException("No WebApplicationContext found:no ContextLoaderListener registered?");
                }
                this.delegate = initDelegate(wac); // 该方法中的 代码
                Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);
            }
            delegateToUse = this.delegate;
        } // Let the delegate perform the actual doFilter operation.
        invokeDelegate(delegateToUse, request, response, filterChain);
    }</pre>
</p>
<p>
    这里需要注意一点 filter-name 必须为&nbsp;springSecurityFilterChain，从DelegatingFilterProxy这个名字中可以猜到这只是个代理类（确实如此），当这个类执行时会去取得真正的filter类，这个类在spring容器中默认生成id为&nbsp;springSecurityFilterChain，在3.0中 该filter 添加了一个 targetName 字段，可以从上面红色代码部分看到它的作用，因此可以通过指定targetName字段，来防止和项目中的其他filter冲突。
</p>
<p>
    <br />
</p>
<p>
    接下来 该真正的 filterChain出场了，这个类是security事务相关的，应该在security包中。
</p>
<p>
    于是 在 spring-security-web jar中发现了这个类:org.springframeword.security.web.FilterChainProxy ,进去看看可以看出这个就是我要找的类。（关于这一点我是从命名上看出来的，bean的id要和类名保持一致）。
</p>
<p>
    <br />
</p>
<p>
    下班了 ，回去再继续添加。
</p>
<p>
    ==========================华丽丽的分界线====================================
</p>
<p>
    <br />
</p>
<p>
    吃完饭 ，继续。
</p>
<p>
    FilterChainProxy 代码：
</p>
<p>
<pre class="prettyprint lang-java linenums">public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {

        FilterInvocation fi = new FilterInvocation(request, response, chain);
        List filters = getFilters(fi.getRequestUrl());
        // 根据url 得到需要经过的filters
        // 这里不是很明白，有知道的同学可以留言。
        if (filters == null || filters.size() == 0) { // 如果没有合适的 ，就继续进行filter
            if (logger.isDebugEnabled()) {
                logger.debug(fi.getRequestUrl() + filters == null ? " has no matching filters": " has an empty filter list");
            }
            chain.doFilter(request, response);
            return;
        }
        // 如果有filter 就进行虚拟的filter链。这里并没有跳出容器的 filter链，
        // 当这个虚拟的filter链完成之后，就继续进行 容器的filter
        VirtualFilterChain virtualFilterChain = new VirtualFilterChain(fi,filters);
        virtualFilterChain.doFilter(fi.getRequest(), fi.getResponse());
    }</pre>
</p>
<p>
    接下来就该进行 filterChain了，在security中有好多的filter：
</p>
<p>
    CHANNEL_FILTER ChannelProcessingFilter
</p>
<p>
    CONCURRENT_SESSION_FILTER ConcurrentSessionFilter
</p>
<p>
    SESSION_CONTEXT_INTEGRATION_FILTER HttpSessionContextIntegrationFilter
</p>
<p>
    LOGOUT_FILTER LogoutFilter
</p>
<p>
    X509_FILTER X509PreAuthenticatedProcessigFilter
</p>
<p>
    PRE_AUTH_FILTER Subclass of AstractPreAuthenticatedProcessingFilter
</p>
<p>
    CAS_PROCESSING_FILTER CasProcessingFilter
</p>
<p>
    AUTHENTICATION_PROCESSING_FILTER AuthenticationProcessingFilter
</p>
<p>
    BASIC_PROCESSING_FILTER BasicProcessingFilter
</p>
<p>
    SERVLET_API_SUPPORT_FILTER classname
</p>
<p>
    REMEMBER_ME_FILTER RememberMeProcessingFilter
</p>
<p>
    ANONYMOUS_FILTER AnonymousProcessingFilter
</p>
<p>
    EXCEPTION_TRANSLATION_FILTER ExceptionTranslationFilter
</p>
<p>
    NTLM_FILTER NtlmProcessingFilter
</p>
<p>
    FILTER_SECURITY_INTERCEPTOR FilterSecurityInterceptor
</p>
<p>
    SWITCH_USER_FILTER SwitchUserProcessingFilter 。
</p>
<p>
    <br />
</p>
<p>
    下面我只分析了 AuthenticationProcessingFilter,这是登录认证处理filter
</p>
<p>
<pre class="prettyprint lang-java linenums">public UsernamePasswordAuthenticationFilter() {
        super("/j_spring_security_check");// 这就是 登录验证的 url。
    }
    public Authentication attemptAuthentication(HttpServletRequest request,
            HttpServletResponse response) throws AuthenticationException {
        if (postOnly &amp;&amp; !request.getMethod().equals("POST")) {
            throw new AuthenticationServiceException(
                    "Authentication method not supported: "
                            + request.getMethod());
        } // 只允许以post方法 进行认证，能防止一些简单的破解
        String username = obtainUsername(request);
        String password = obtainPassword(request);

        if (username == null) {
            username = "";
        }
        if (password == null) {
            password = "";
        }
        username = username.trim();
        // 只是将 username和password封装进去
        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);

        // Place the last username attempted into HttpSession for views
        HttpSession session = request.getSession(false);
        if (session != null || getAllowSessionCreation()) {
            request.getSession().setAttribute(
                    SPRING_SECURITY_LAST_USERNAME_KEY,
                    TextEscapeUtils.escapeEntities(username));
        }
        setDetails(request, authRequest);
        // 取得AuthenticationManager 进行认证
        return this.getAuthenticationManager().authenticate(authRequest);
    }</pre>
</p>
<p>
    从request中取得 username，password，封装进 UsernamePasswordAuthenticationToken 中，
</p>
<p>
    然后将username中写到 session中，这里对username去掉了首尾的空格
</p>
<p>
    然后调用 AuthenticationManager的 authenticate方法进行具体的认证操作。
</p>
<p>
<pre class="prettyprint lang-java linenums">public Authentication doAuthentication(Authentication authentication)
            throws AuthenticationException {
        Class toTest = authentication.getClass();
        AuthenticationException lastException = null;
        Authentication result = null;
        for (AuthenticationProvider provider : getProviders()) {
            if (!provider.supports(toTest)) {
                continue;
            }
            logger.debug("Authentication attempt using "+ provider.getClass().getName());
            try {
                result = provider.authenticate(authentication);
                if (result != null) {
                    copyDetails(authentication, result);
                    break;
                }
            } catch (AccountStatusException e) {
                // SEC-546: Avoid polling additional providers if auth failure
                // is due to invalid account status
                eventPublisher.publishAuthenticationFailure(e, authentication);
                throw e;
            } catch (AuthenticationException e) {
                lastException = e;
            }
        }
        if (result == null &amp;&amp; parent != null) {
            // Allow the parent to try.
            try {
                result = parent.authenticate(authentication);
            } catch (ProviderNotFoundException e) {
                // ignore as we will throw below if no other exception occurred
                // prior to calling parent and the parent
                // may throw ProviderNotFound even though a provider in the
                // child already handled the request
            } catch (AuthenticationException e) {
                lastException = e;
            }
        }
        if (result != null) {
            if (eraseCredentialsAfterAuthentication
                    &amp;&amp; (result instanceof CredentialsContainer)) {
                // Authentication is complete. Remove credentials and other
                // secret data from authentication
                ((CredentialsContainer) result).eraseCredentials();
            }
            eventPublisher.publishAuthenticationSuccess(result);
            return result;
        }
        // Parent was null, or didn't authenticate (or throw an exception).
        if (lastException == null) {
            lastException = new ProviderNotFoundException(messages.getMessage("ProviderManager.providerNotFound",new Object[] { toTest.getName() },
                    "No AuthenticationProvider found for {0}"));
        }
        eventPublisher.publishAuthenticationFailure(lastException,authentication);
        throw lastException;
    }</pre>
</p>
<p>
    这里对 用户进行认证，成功就发布成功事件，并返回。 失败就发布失败事件，并返回exception
</p>
<p>
    这里具体的认证过程还是不大熟悉，等再详细的看明白了 再细说。
</p>
<p>
    看明白了，authenticationManager可以有多个 provider如 默认的daoAuthenticationProvider 和 &nbsp;JaasAuth ，RememmberMeAuth 等
</p>
<p>
    下面说 daoAuthenticationProvider 中可以有 &nbsp;UserDetailsService ，
</p>
<p>
<pre class="prettyprint lang-java linenums">        protected final UserDetails retrieveUser(String username,
            UsernamePasswordAuthenticationToken authentication)
            throws AuthenticationException {
        UserDetails loadedUser;
        try {
            loadedUser = this.getUserDetailsService().loadUserByUsername(username);
        } catch (DataAccessException repositoryProblem) {
            throw new AuthenticationServiceException(repositoryProblem.getMessage(), repositoryProblem);
        }
        if (loadedUser == null) {
            throw new AuthenticationServiceException(
                    "UserDetailsService returned null, which is an interface contract violation");
        }
        return loadedUser;
    }</pre>
</p>
<p>
    又通过 userDetailsService.loadUserByUsername() &nbsp;，当不存在时 ，返回null
</p>
<p>
    来得到 UserDetails 这样就能把 整个认证过程理顺了
</p>
<p>
    <br />
</p>
<p>
    总结一下， &nbsp;security 的认证过程能理顺了，对其衔接的过渡代码 还有些拿不准，还有 取得filters的 规则还不是很清楚，还要继续看下去。
</p>
<p>
    已经能理顺了， 在BeanId 类中发现了那些默认的字符串，这样 在spring 解析xml时，遇到 security的标签后，会将这个节点交给 security下的类来执行SecurityNamespaceHandler。
</p>
<p>
    这样就能保证security初始化的正常。包括生成默认的 FilterChainProxy 和添加一些依赖。生成 AuthenticationManager及其依赖的 ProviderManager 等。
</p>
<p>
    下次，继续看 url资源控制部分
</p>

    <hr>
    <div class="pagination">
      <ul>
        <ul>
          
            <li class="prev"><a href="/2011/89.html" title="pe下安装win7">&larr; Previous</a></li>
          
          

            <li><a href="/archive">Archive</a></li>

          
            <li class="next"><a href="/2011/87.html" title="自己的年终总结">Next &rarr;</a></li>
          
          
        </ul>
      </ul>
    </div>
    <hr>
     
  </div>
  
  <div class="span4">
    <h4>Published</h4>
    <div class="date"><span>2011-01-25</span></div>
    <br>
    <h4>Share to Weixin</h4>
    <div id="share-qrcode"></div>
    <script type="text/javascript">
      new QRCode(document.getElementById("share-qrcode"), {
        text:document.URL,
        width:128,
        height:128
      });
    </script>
    <br>
    <h4>Categories</h4>
    <ul class="tag_box">
    
      <li>
  <a href="/categories/#%E9%BB%98%E8%AE%A4-ref">默认 <span>104</span></a>
</li>
    
    </ul>
    <br>
    <h4>Tags</h4>
    <ul class="tag_box">
    
    </ul>
  </div>
</div>

      <footer>
        <p>&copy; 盒子 2016
          with help from <a href="http://github.com/wendal/gor" target="_blank" title="Gor -- Fast Blog">Gor</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
		  and Idea from <a href="http://ruhoh.com" target="_blank" title="The Definitive Technical Blogging Framework">ruhoh</a>
            <a href="http://www.miitbeian.gov.cn" target="_blank">京ICP备17040577号-1</a> 
        </p>
      </footer>
    </div> <!-- /container -->
  </body>
</html>
